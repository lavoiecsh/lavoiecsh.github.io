"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[5441],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||i;return n?a.createElement(m,r(r({ref:t},p),{},{components:n})):a.createElement(m,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8429:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=n(7462),o=(n(7294),n(3905));const i={title:"React + Redux + Saga",tags:["Practices","Javascript"]},r=void 0,s={permalink:"/2019/11/04/react",source:"@site/blog/2019/11-04-react.md",title:"React + Redux + Saga",description:"After working a little with the React-Redux-Saga ecosystem, and working with others that were still new to it, I came to realize some parts of the frameworks can be a little confusing so I decided to write this post to explain how everything works together. This article isn't meant to explain everything, but give a brief overview of the different sections of the ecosystem and how they interact with each other in case you need to work on an existing project or need to think about which technology to use for new project.",date:"2019-11-04T00:00:00.000Z",formattedDate:"November 4, 2019",tags:[{label:"Practices",permalink:"/tags/practices"},{label:"Javascript",permalink:"/tags/javascript"}],readingTime:9.925,hasTruncateMarker:!0,authors:[],frontMatter:{title:"React + Redux + Saga",tags:["Practices","Javascript"]},prevItem:{title:"The problem with java isn't the language, it's the rest",permalink:"/2019/11/26/java"},nextItem:{title:"Indentation",permalink:"/2019/08/06/indentation"}},l={authorsImageUrls:[]},c=[{value:"React",id:"react",level:2},{value:"Lifecycle",id:"lifecycle",level:3},{value:"Properties",id:"properties",level:3},{value:"Unit testing",id:"unit-testing",level:3},{value:"Shallow Rendering",id:"shallow-rendering",level:4},{value:"Full DOM Rendering",id:"full-dom-rendering",level:4},{value:"Static Rendering",id:"static-rendering",level:4},{value:"Redux",id:"redux",level:2},{value:"Actions",id:"actions",level:3},{value:"Reducers",id:"reducers",level:3},{value:"Connected Components",id:"connected-components",level:3},{value:"Event-driven architecture",id:"event-driven-architecture",level:3},{value:"Unit testing",id:"unit-testing-1",level:3},{value:"Saga",id:"saga",level:2},{value:"Unit testing",id:"unit-testing-2",level:3}],p={toc:c},d="wrapper";function h(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"After working a little with the React-Redux-Saga ecosystem, and working with others that were still new to it, I came to realize some parts of the frameworks can be a little confusing so I decided to write this post to explain how everything works together. This article isn't meant to explain everything, but give a brief overview of the different sections of the ecosystem and how they interact with each other in case you need to work on an existing project or need to think about which technology to use for new project."),(0,o.kt)("h2",{id:"react"},"React"),(0,o.kt)("p",null,"React is essentially a framework to easily divide your front-end application in different components which interact together to form your application. This helps separate concerns for the different parts of your application and reuse some of the components you create."),(0,o.kt)("p",null,"You define your components using either a class or a function syntax:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"class Welcome extends React.Component {\n    render() {\n        return <h1>Hello, {this.props.name}</h1>;\n    }\n}\n\nfunction Welcome(props) {\n    return <h1>Hello, {props.name}</h1>;\n}\n\nfunction Welcome(props) => <h1>Hello, {props.name}</h1>;\n")),(0,o.kt)("p",null,"All these define a ",(0,o.kt)("inlineCode",{parentName:"p"},"Welcome")," component that can be used inside other components with ",(0,o.kt)("inlineCode",{parentName:"p"},'<Welcome name="myname"/>'),". In the later version of React, function components can do anything a class component can, the only difference being the syntax."),(0,o.kt)("h3",{id:"lifecycle"},"Lifecycle"),(0,o.kt)("p",null,"A big part of React's component is the lifecycle. It's important to understand what is available at which point in the lifecycle. New components follow four basic steps: "),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"constructor (for class components)"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"render")," function for class components or the function itself for function components"),(0,o.kt)("li",{parentName:"ol"},"React updates the DOM"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"componentDidMount")," (for class components)")),(0,o.kt)("p",null,"This means that React renders everything inside a temporary buffer before sending it to the DOM for the user to see and interact with. For most components, the ",(0,o.kt)("inlineCode",{parentName:"p"},"render")," function is enough to handle everything needed. In cases where you want to do something when the page loads or is loaded, your best bet is the ",(0,o.kt)("inlineCode",{parentName:"p"},"componentDidMount")," function. This ensures the component is properly mounted before you change anything inside it, as changes before mounting is done will not be visible."),(0,o.kt)("p",null,"Updating a component is triggered either by changing their properties, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"setState")," function inside the component or calling ",(0,o.kt)("inlineCode",{parentName:"p"},"forceUpdate")," for your component. In this case, the component will follow these three steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"render")),(0,o.kt)("li",{parentName:"ol"},"React updates the DOM"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"componentDidUpdate"))),(0,o.kt)("p",null,"When unmounting a component, it will only call the ",(0,o.kt)("inlineCode",{parentName:"p"},"componentWillUnmount")," if it is defined."),(0,o.kt)("h3",{id:"properties"},"Properties"),(0,o.kt)("p",null,"Every component defines a set of properties that are used to customize it. Properties cannot be modified inside the component, they are simply there to change the behaviour of the component when it renders, or handles any action. You can define the properties you're expecting in your component as well as types for these properties by adding a propTypes property on your component class:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import PropTypes from 'prop-types';\n\nWelcome.propTypes = {\n    name: PropTypes.string\n};\n")),(0,o.kt)("p",null,"The advantage of this is that most editors read these and help you with autocompletion and errors if you didn't add a required property or added an undefined property. You can also define defaults for the properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"Welcome.defaultProps = {\n    name: 'stranger'\n};\n")),(0,o.kt)("h3",{id:"unit-testing"},"Unit testing"),(0,o.kt)("p",null,"Unit testing your components can be done with ",(0,o.kt)("inlineCode",{parentName:"p"},"enzyme"),", a renderer for React components which let's you inspect the components to validate that they will be displayed correctly. Enzyme offers three rendering methods, all of which define a function taking your component as argument and returning a Renderer object containing methods to inspect the output:"),(0,o.kt)("h4",{id:"shallow-rendering"},"Shallow Rendering"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"shallow(node) => ShallowRenderer"),"\nThis renders the component without rendering any child component. This means that the output of shallow will contain the tags specified by the used components and not their html representation. This is particularly useful when you want to unit test a component, and whether it correctly adds a child component or not."),(0,o.kt)("h4",{id:"full-dom-rendering"},"Full DOM Rendering"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"mount(node) => ReactWrapper"),"\nThis renders the components and all its children. The output will contain valid html equivalent to what is being rendered to the user when using the application. This can be useful to test interactions with the DOM APIs. It requires a DOM, which is available in a browser or with the jsdom library. Since it is mounting the HTML in the DOM (similarly to how React actually works), you may need to use unmount between tests to clean your DOM so your tests don't impact each other."),(0,o.kt)("h4",{id:"static-rendering"},"Static Rendering"),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"render(node) => CheerioWrapper"),"\nThis uses Cheerio, a library to render static HTML, to render the HTML statically for your component and its children. It only does rendering, it does not call React's component lifecycle and does not interact with the DOM. This is rarely used in practice since ",(0,o.kt)("inlineCode",{parentName:"p"},"shallow")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"mount")," offer more without increasing testing time. "),(0,o.kt)("h2",{id:"redux"},"Redux"),(0,o.kt)("p",null,"Redux is a library on top of React which adds a sharable state between the components as well as an event-driven architecture to help the components interact with each other."),(0,o.kt)("h3",{id:"actions"},"Actions"),(0,o.kt)("p",null,"Redux lets you define actions which you can trigger manually whenever something happens. This is the publishing part of the event-driven architecture. Actions can also contain additional data. They are defined with the ",(0,o.kt)("inlineCode",{parentName:"p"},"createAction")," function and triggered by calling the returned function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// define the action in a shared file\nexport buttonPressed = createAction('BUTTON_PRESSED');\n// use the action in your component\nbuttonPressed(additionalData);\n")),(0,o.kt)("h3",{id:"reducers"},"Reducers"),(0,o.kt)("p",null,"Reducers are functions triggered whenever a specific action is triggered. Their purpose is to update the global state depending on the triggered action and its additional data. They are created with the ",(0,o.kt)("inlineCode",{parentName:"p"},"handleAction")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"handleActions")," functions with an initial state and a function mapping the received state to the new global state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"handleActions({\n    BUTTON_PRESSED: (state) => ({ ...state, somethingElse: true }),\n    OTHER_BUTTON_PRESSED: (state) => ({ somethingElse: false })\n}, { somethingElse: false });\n")),(0,o.kt)("h3",{id:"connected-components"},"Connected Components"),(0,o.kt)("p",null,"Since React updates the components only when their properties are changed, they will not be updated when the global state changes unless they are connected to the Redux engine. To connect your component, you need to define a ",(0,o.kt)("inlineCode",{parentName:"p"},"mapStateToProps")," function that reads the new state and maps values from it to your components properties. You can also define a ",(0,o.kt)("inlineCode",{parentName:"p"},"mapDispatchToProps")," object that will set some of your properties to actions you created previously (similarly to the ",(0,o.kt)("inlineCode",{parentName:"p"},"defaultProps")," object). With all this, you then export a connected component instead of your previous component with the ",(0,o.kt)("inlineCode",{parentName:"p"},"connect")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"import buttonPressed from './actions';\n\nmapStateToProps = (state) => ({\n    myProp: state.somethingElse\n});\n\nmapDispatchToProps = {\n    buttonPressed\n};\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Welcome);\n")),(0,o.kt)("h3",{id:"event-driven-architecture"},"Event-driven architecture"),(0,o.kt)("p",null,"As mentioned, Redux uses an event-driven architecture style which will usually follow this lifecycle:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"User interacts with your component"),(0,o.kt)("li",{parentName:"ol"},"Component triggers an action"),(0,o.kt)("li",{parentName:"ol"},"All reducers for that action will be called to modify the global state"),(0,o.kt)("li",{parentName:"ol"},"mapStateToProps will be called on each component with the new global state"),(0,o.kt)("li",{parentName:"ol"},"any component that changes a property during mapStateToProps will trigger it's update lifecycle and be updated")),(0,o.kt)("p",null,"This helps to separate concerns inside your application. Actions are just placeholders to separate the different actions that can happen in your application. Reducers only need to know how to modify the state whenever a specific action is called. Components only need to know which action to trigger and their ",(0,o.kt)("inlineCode",{parentName:"p"},"mapStateToProps")," only need to know what to do with the new state."),(0,o.kt)("p",null,"It also allows you to make modifications to other components from a component since all the reducers and ",(0,o.kt)("inlineCode",{parentName:"p"},"mapStateToProps")," will be executed when an action is triggered."),(0,o.kt)("p",null,"The biggest thing to remember when using actions, reducers and connect components is that you want each action to be as simple as possible. This is why thinking in events is usually easier: text changed, button clicked, etc. Since the actions, reducers and state are global to your application, make sure to name them well and not reuse the same names for actions or state values."),(0,o.kt)("h3",{id:"unit-testing-1"},"Unit testing"),(0,o.kt)("p",null,"Actions cannot be unit tested as they are just definitions."),(0,o.kt)("p",null,"Reducers can easily be unit tested by ensuring the new state reflects the expected changes depending on the triggered action and additional information. The ",(0,o.kt)("inlineCode",{parentName:"p"},"handleActions")," function returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"reducer")," function that takes an initial state and a object containing the type of triggered action (the string argument when you ",(0,o.kt)("inlineCode",{parentName:"p"},"createAction"),") and the additional data as a payload. Executing this function returns the new state, making unit testing very simple:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"expect(reducer({\n    // empty initial state\n}, {\n    type: BUTTON_PRESSED,\n    payload: { newValue: 'test' }\n})).toEqual({\n    newValue: 'test',\n    somethingElse: true\n});\n")),(0,o.kt)("p",null,"For components, you will need to unit test the initial rendering (as before), the ",(0,o.kt)("inlineCode",{parentName:"p"},"mapStateToProps")," function which is pretty straight forward and make sure that actions are correctly triggered when an action happens. This requires shallow or full DOM rendering (static rendering doesn't work)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"define('welcome', () => {\n    let component;\n    const props = {\n        buttonPressed: jest.fn(),\n        name: 'test'\n    };\n    \n    beforeEach(() => {\n        jest.clearAllMocks();\n        component = shallow(<Welcome {...props}/>);    \n    });\n\n    it('renders correctly', () => {\n        expect(component.find('something').props().name).toEqual(props.name);    \n    });\n\n    it('triggers action when button is pressed', () => {\n        component.find('button').simulate('click');\n\n        expect(props.buttonPressed).toHaveBeenCalledWith({ name: 'test' });\n    });\n});\n")),(0,o.kt)("h2",{id:"saga"},"Saga"),(0,o.kt)("p",null,"As you probably guessed, some things are still a little complicated when using React with Redux, especially handling promises and such when calling apis to fetch data or make modifications. The React-Redux-Saga library helps greatly with this. Saga is a design pattern initially defined to handle interactions with multiple components you may or may not control. It is especially useful when your application must call multiple apis and revert each call if one of them failed."),(0,o.kt)("p",null,"Most of the time when you need to fetch data with React-Redux, you'll end up with a call to an api that returns a promise. Once it resolves, you trigger the action associated with it. For simple cases like this, you may find Saga a little overwhelming, but for more complicated cases it greatly helps to reduce duplication and helps extract api logic from your components."),(0,o.kt)("p",null,"In React-Redux-Saga, you define generator functions that are executed when an action is triggered. They essentially act as a reducer with more logic."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function* mySaga() {\n    // execute when buttonPressed is triggered\n    const additionalData = yield take('BUTTON_PRESSED');\n    // fetch some data\n    const initialData = yield call(fetch(additionalData.id));\n    // fetch some other data\n    const moreData = yield call(fetchOther(initialData.something));\n    // fetch some state value\n    const stateData = yield select(state => state.somethingElse);\n    // trigger an action with the fetched data\n    yield put(dataFetched({ ...initialData, ...moreData, ...stateData }));\n}\n")),(0,o.kt)("h3",{id:"unit-testing-2"},"Unit testing"),(0,o.kt)("p",null,"There are two methods to unit testing sagas. The first method goes through the generator function and expects the returns at each yield. This tightly couples your test code to your saga code, making any changes painful since you'll need to modify all the tests whenever you need to change the saga code."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"const gen = mySaga();\nexpect(gen.next()).toEqual(take('BUTTON_PRESSED'));\nexpect(gen.next({ id: 'id' })).toEqual(fetch('id'));\nexpect(gen.next({ something: 2 })).toEqual(fetchOther(2));\nexpect(gen.next({ blah: [] })).toEqual(select(state => state.somethingElse));\nexpect(gen.next({ test: 'abc' })).toEqual(put(dataFetched({ id: 'id', something: 2, blah: [], test: 'abc'})));\nexpect(gen.next()).toEqual({ done: true, value: undefined });\n")),(0,o.kt)("p",null,"This can quickly become painful to maintain and debug if there is a problem."),(0,o.kt)("p",null,"The other method is to actually run the saga and expect the resulting dispatched actions."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"fetch = jest.fn().mockReturnValue({ something: 2 });\nfetchOther = jest.fn().mockReturnValue({ blah: [] });\n\nconst dispatched = [];\nconst saga = await runSaga({\n    dispatch: (action) => dispatched.push(action),\n    getState: () => ({ somethingElse: 'abc' })\n}, mySaga, {id:'id'}).toPromise();\n\nexpect(dispatched).toEqual([\n    dataFetched({ id: 'id', something: 2, blah: [], test: 'abc' })\n]);\n")),(0,o.kt)("p",null,"Since you only expect the dispatch items to contain the desired actions and data, changing the saga code has less chances to break the tests unless the actual logic of the saga changes. With more complicated sagas, it becomes a much more powerful tool since you're actually testing the output of the function depending on the input and not the implementation."))}h.isMDXComponent=!0}}]);