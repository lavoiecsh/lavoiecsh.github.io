"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[532],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},g="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=p(a),d=i,h=g["".concat(l,".").concat(d)]||g[d]||u[d]||r;return a?n.createElement(h,o(o({ref:t},c),{},{components:a})):n.createElement(h,o({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[g]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},6773:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={title:"Jekyll, pagination, categorizing and Javascript",tags:["Blog","Update"]},o=void 0,s={permalink:"/2019/03/03/jekyll-javascript",source:"@site/blog/2019/03-03-jekyll-javascript.md",title:"Jekyll, pagination, categorizing and Javascript",description:"As some of you may know Jekyll is an application to build static websites. It's used by GitHub-Pages (where this blog is residing). One of the disadvantages of having a static website is that every page must be created before publishing it. This means that you cannot do filtering based on query parameters and such, and all the sub-pages for pagination must be generated before hand. Jekyll does allow extensions in Ruby to generate the pages, one of which is a paginator, but for some reason I've had trouble making it work on GitHub-Pages. The paginator also doesn't work with multiple languages like this blog.",date:"2019-03-03T00:00:00.000Z",formattedDate:"March 3, 2019",tags:[{label:"Blog",permalink:"/tags/blog"},{label:"Update",permalink:"/tags/update"}],readingTime:2.335,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Jekyll, pagination, categorizing and Javascript",tags:["Blog","Update"]},prevItem:{title:"New stuff in C#8: Nullable Reference Types",permalink:"/2019/03/19/cs8-nullable-reference-types"},nextItem:{title:"WSL (or why I won't make Linux VMs in Windows)",permalink:"/2019/02/21/wsl"}},l={authorsImageUrls:[]},p=[{value:"Categorizing",id:"categorizing",level:3},{value:"Pagination",id:"pagination",level:3},{value:"Disclaimer",id:"disclaimer",level:3},{value:"So what&#39;s left after this update?",id:"so-whats-left-after-this-update",level:3}],c={toc:p},g="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(g,(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"As some of you may know Jekyll is an application to build static websites. It's used by GitHub-Pages (where this blog is residing). One of the disadvantages of having a static website is that every page must be created before publishing it. This means that you cannot do filtering based on query parameters and such, and all the sub-pages for pagination must be generated before hand. Jekyll does allow extensions in Ruby to generate the pages, one of which is a paginator, but for some reason I've had trouble making it work on GitHub-Pages. The paginator also doesn't work with multiple languages like this blog."),(0,i.kt)("p",null,"After trying all this for a while, I decided to go the old route and add a bit of Javascript to my pages to add pagination and categorizing. I used ES6 Javascript with no additional libraries (like JQuery)."),(0,i.kt)("h3",{id:"categorizing"},"Categorizing"),(0,i.kt)("p",null,"Categorizing has been achieved by removing posts from the list if they don't fit the currently selected. I added a query parameter to the Posts by category links on the left of the page and retrieve it with the following Javascript code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"const categories = window.location.search.substr(1).split('&').map(v => v.split('='));\nreturn new Map(categories).get('category');\n")),(0,i.kt)("p",null,"Filtering is then accomplished with this bit of code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"let postList = document.querySelector('ul.post-list');\ndocument.querySelectorAll('ul.post-list li')\n    .forEach(post => post.dataset.category !== category && postList.removeChild(post));\n")),(0,i.kt)("h3",{id:"pagination"},"Pagination"),(0,i.kt)("p",null,"Once this is done I add pagination by creating ",(0,i.kt)("inlineCode",{parentName:"p"},"li")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"button")," elements in an empty ",(0,i.kt)("inlineCode",{parentName:"p"},"ul")," already in the page. Page selection is then accomplished by hiding the posts from other pages while showing the posts from the current page."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"class Paginator {\n    constructor(pageSize) {\n        this.pageSize = pageSize;\n        this.posts = document.querySelectorAll('ul.post-list li');\n        this.pageCount = Math.ceil(this.posts.length / this.pageSize);\n    }\n\n    paginate() {\n        if (this.posts.length === 0) return;\n        this.addPagination();\n        this.selectPage(1);\n    }\n\n    addPagination() {\n        const pageListElement = document.querySelector('ul.page-list');\n        for (let i = 1; i <= this.pageCount; ++i) {\n            let pageElement = document.createElement('li');\n            let pageAnchor = document.createElement('button');\n            pageAnchor.addEventListener('click', () => this.selectPage(i));\n            pageAnchor.innerText = i.toString();\n            pageElement.appendChild(pageAnchor);\n            pageListElement.appendChild(pageElement);\n        }\n        this.pages = document.querySelectorAll('ul.page-list li');\n    }\n\n    selectPage(page) {\n        for (let i = 1; i <= this.pages.length; ++i) {\n            if (i === page)\n                this.pages[i-1].classList.add('current-page');\n            else\n                this.pages[i-1].classList.remove('current-page');\n        }\n        for (let i = 1; i <= this.posts.length; ++i) {\n            if (Math.ceil(i / this.pageSize) === page)\n                this.posts[i-1].removeAttribute('hidden');\n            else\n                this.posts[i-1].setAttribute('hidden', true);\n        }\n    }\n}\n")),(0,i.kt)("h3",{id:"disclaimer"},"Disclaimer"),(0,i.kt)("p",null,"I am aware this will not work in older browsers or with Javascript disabled, but I'm guessing people that read this blog will be using a recent browser anyway. Not running the Javascript on the index page will simply mean that categorizing and pagination will not work, but the actual website will still continue working as it should."),(0,i.kt)("h3",{id:"so-whats-left-after-this-update"},"So what's left after this update?"),(0,i.kt)("p",null,"Fixing dates so they show according to the language (which seems to require a lot of code). More CSS everywhere."))}u.isMDXComponent=!0}}]);