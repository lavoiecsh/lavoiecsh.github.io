"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[3541],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),h=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=h(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=h(n),p=i,f=u["".concat(s,".").concat(p)]||u[p]||c[p]||a;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function f(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:i,o[1]=l;for(var h=2;h<a;h++)o[h]=n[h];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1217:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>h});var r=n(7462),i=(n(7294),n(3905));const a={title:"Thinking in resolvers",tags:["Technologies","GraphQL"]},o="Thinking in Resolvers",l={permalink:"/2020/10/15/thinking-in-resolvers",source:"@site/blog/2020/10-15-thinking-in-resolvers.md",title:"Thinking in resolvers",description:"Everything in GraphQL revolves around resolvers. It's important to understand this to better develop application exposing GraphQL APIs.",date:"2020-10-15T00:00:00.000Z",formattedDate:"October 15, 2020",tags:[{label:"Technologies",permalink:"/tags/technologies"},{label:"GraphQL",permalink:"/tags/graph-ql"}],readingTime:7.815,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Thinking in resolvers",tags:["Technologies","GraphQL"]},prevItem:{title:"Advent of Code 2021",permalink:"/2021/11/20/advent2021"},nextItem:{title:"Advent of Code 2019",permalink:"/2019/12/02/advent2019"}},s={authorsImageUrls:[]},h=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Resolver Anatomy",id:"resolver-anatomy",level:2},{value:"Field within a type",id:"field-within-a-type",level:2},{value:"The special (but not so special) cases",id:"the-special-but-not-so-special-cases",level:2},{value:"Federation",id:"federation",level:2},{value:"Allowing extensions",id:"allowing-extensions",level:3},{value:"Extending",id:"extending",level:3},{value:"Referencing",id:"referencing",level:3},{value:"Resolving References",id:"resolving-references",level:3},{value:"Notes on Queries",id:"notes-on-queries",level:3},{value:"Directives",id:"directives",level:2}],d={toc:h},u="wrapper";function c(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Everything in GraphQL revolves around resolvers. It's important to understand this to better develop application exposing GraphQL APIs."),(0,i.kt)("h2",{id:"table-of-contents"},"Table of Contents"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#resolver-anatomy"},"Resolver Anatomy")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#field-within-a-type"},"Field within a type")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#the-special-but-not-so-special-cases"},"The special (but not so special) cases")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#federation"},"Federation")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#directives"},"Directives"))),(0,i.kt)("h2",{id:"resolver-anatomy"},"Resolver Anatomy"),(0,i.kt)("p",null,"A resolver is a function returning the value of a field within a type. It takes in four arguments:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"parent: the instance returned by the parent resolver"),(0,i.kt)("li",{parentName:"ol"},"args/input: any additional input to the field (usually what's in parentheses in the schema)"),(0,i.kt)("li",{parentName:"ol"},"context: an object built by the server before resolver each query that usually contains globally accessible information and information about the current query"),(0,i.kt)("li",{parentName:"ol"},"info: information about the fields, types, queries being executed")),(0,i.kt)("p",null,"Most of the time we use the first three arguments to resolve a field. The fourth argument is usually discarded as the information is seldom useful."),(0,i.kt)("p",null,"For most GraphQL server implementations, resolvers are referenced within a hierarchy of Type to field."),(0,i.kt)("h2",{id:"field-within-a-type"},"Field within a type"),(0,i.kt)("p",null,"Each field within a type uses a resolver to define the value to return for this field and a particular instance of the parent type. Looking at the following schema:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"type Product {\n  id: ID!\n  type: ProductType!\n  name(locale: Locale): String\n}\n")),(0,i.kt)("p",null,"This product type has three fields: id, type and name. Assuming the user wants all three fields to be returned and the product instance is already resolved, three resolvers will be called to get the value for aech field. In each case the parent parameter will be the instance of the product type that has been resolved previously and the context will receive what was built by the server. Additionally, the args parameter will be empty for the id and type fields, and contain the given locale for the name field. Each of these resolvers will be included in the Product type."),(0,i.kt)("p",null,"There is a default resolver that takes the value from the parent if that parent has a property matching the field we are resolving. You can override this resolver to add more logic when resolving the field:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Not returning the value if the user doesn't have sufficient permissions"),(0,i.kt)("li",{parentName:"ul"},"Returning a different value in some cases"),(0,i.kt)("li",{parentName:"ul"},"Returning a calculated value"),(0,i.kt)("li",{parentName:"ul"},"Fetching data from a different table/collection in your database")),(0,i.kt)("h2",{id:"the-special-but-not-so-special-cases"},"The special (but not so special) cases"),(0,i.kt)("p",null,'Query, Mutation and Subscription types in GraphQL let you define the basic API you are exposing to the clients. These are referred to as the "root" types and are predefined by the specification.'),(0,i.kt)("p",null,"These are still types in the sense that they contain fields that will be resolved through resolvers just like any other field within a type. The only different is that there is no default resolver for these types and you must then write the resolvers yourself. As for the arguments, they function the same way as for other field resolvers, although the parent parameter will be defined by the GraphQL implementation you use (usually null or an empty object)."),(0,i.kt)("p",null,"Since these are still types from the GraphQL point of view, each query is a field with a resolver within the Query type, each mutation is a field with a resolver within the Mutation type, and each subscription is a field with a resolver within the Subscription type."),(0,i.kt)("h2",{id:"federation"},"Federation"),(0,i.kt)("p",null,"Federation lets you define fields on types outside your domain and lets you return references to types outside your domain for fields in your domain. The gateway will handle which resolver to call for each field."),(0,i.kt)("h3",{id:"allowing-extensions"},"Allowing extensions"),(0,i.kt)("p",null,"When creating a type that could be extended by other services, you need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@key")," directive to indicate which fields will be exposed to the other services."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'type Product @key(fields: "id state") {\n  id: ID!\n  state: ProductState!\n  type: ProductType!\n  ...\n}\n')),(0,i.kt)("p",null,"The key in this case will contain the id and state fields, but not the type field."),(0,i.kt)("h3",{id:"extending"},"Extending"),(0,i.kt)("p",null,"When extending a type to add a new field, you create an extended type in your schema using the ",(0,i.kt)("inlineCode",{parentName:"p"},"@extends")," keyword. The ",(0,i.kt)("inlineCode",{parentName:"p"},"@key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@external")," directives indicates the fields that are required for you to be able to resolve your additional field, and that these are coming from another service."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'@extends type Product @key(fields: "id state") {\n  id: ID! @external\n  state: ProductState! @external\n  integrationConfiguration: IntegrationConfiguration\n}\n')),(0,i.kt)("p",null,"When resolving the integrationConfiguration field for a product, the gateway will send the id and state in the parent parameter of the resolver, allowing you to correctly resolve the integrationConfiguration field. This resolver will belong to the Product type within the integration configuration service."),(0,i.kt)("h3",{id:"referencing"},"Referencing"),(0,i.kt)("p",null,"When referencing an outside type within your schema, you need to include an __typename and all the key fields so that the gateway can resolve this reference. For example, again from the integration configuration service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},"type IntegrationConfiguration {\n  id: ID!\n  state: ProductState!\n  products: [Product]\n}\n")),(0,i.kt)("p",null,"To create a backwards reference to the products linked to this integration configuration, you need to create a resolver named ",(0,i.kt)("inlineCode",{parentName:"p"},"products")," in the IntegrationConfiguration type. This resolver will need to return an array of objects containing the id and state of the referenced product as well as the type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "__typename": "Product",\n  "id": "123",\n  "state": "WORKING"\n}\n')),(0,i.kt)("h3",{id:"resolving-references"},"Resolving References"),(0,i.kt)("p",null,"With the resolved value above, the gateway then turns to the product service and asks to resolve the reference through the ",(0,i.kt)("inlineCode",{parentName:"p"},"__resolveReference")," resolver. This is a special case resolver which only takes the parent and context arguments. The parent will contain the value for the key fields returned by the other service and the context will be generated just like any other resolver. This special resolver will be part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Product")," type within the product service."),(0,i.kt)("h3",{id:"notes-on-queries"},"Notes on Queries"),(0,i.kt)("p",null,"With federation, queries will be coming to your service from the GraphQL gateway. These are usually a little obscure but it's useful to know what they look like so you can use them when testing resolvers without the gateway."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-graphql"},'query {\n  _entities(representations: [\n    {\n      __typename: "Product"\n      id: "123"\n      state: WORKING\n    }\n  ]) {\n    ... on Product {\n      type\n    }\n  }\n}\n')),(0,i.kt)("p",null,"This kind of query is used by the gateway to resolve references to objects and additional fields defined in another service with federation. The representations in the ",(0,i.kt)("inlineCode",{parentName:"p"},"_entities")," query defines all the parent objects with all the required fields to resolve whatever was requested by the client."),(0,i.kt)("p",null,"Since the type field resides in the Product type definition for the product service, it will first resolve the product through the ",(0,i.kt)("inlineCode",{parentName:"p"},"__resolveReference")," resolver, passing in the given representation. It will then resolve the type field on the result. This can be used to ensure our ",(0,i.kt)("inlineCode",{parentName:"p"},"__resolveReference")," resolver works as expected."),(0,i.kt)("p",null,"If we ask for the integrationConfiguration field instead of the type field in the same query, we get a query being sent to the integration configuration service to resolve the integration configuration. This will call the integrationConfiguration resolver within the Product type in the intgeration configuration service and pass as parent the given representation. This can be used to test additional fields for extended types in isolation, without needing to run the gateway and the service where the type was originally defined."),(0,i.kt)("p",null,"Representations must contain all the fields defined in the key directive for a type as well as the ",(0,i.kt)("inlineCode",{parentName:"p"},"__typename"),". Notice how this is identical to what we return when we want to resolve a type belonging to another service."),(0,i.kt)("h2",{id:"directives"},"Directives"),(0,i.kt)("p",null,"Once resolvers are clear, you can start to look at directives. A directive is an additional element to the schema to add logic around a resolver. Some directives are predefined by the specification. Federation adds some we previously mentioned:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"@extends")," directive on a type indicates the type we are referencing is part of another service within the global schema. This ensures there are no collisions within a federated schema."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"@key")," directive on a type ensures the key fields are resolved for an instance and extracts them for referencing within federation."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"@external")," directive on a field indicates the field is not resolved by our service.")),(0,i.kt)("p",null,"Directives are executed not when the field is resolved but when the server is started. This means you do not have access to the parent, input and context at the moment the field is resolved, but you can exchange the defined resolver with another one. For those fluent in Object-Oriented design patterns, you can think of them as decorators."),(0,i.kt)("p",null,"Directives can act on a multitude of elements within a GraphQL schema, from the schema itself, to types, fields, enum, enum values, scalars, arguments, input fields, etc. Typical use cases for using directives on fields is to perform validations on the input or verifying the user has the correct authorization before calling the resolver. They can also be used to modify the arguments being sent, such as lower-casing strings, or modify the return value from the resolver, suach as formatting or translating the output."),(0,i.kt)("p",null,"When adding validations to a query or mutation, remember these are still fields within a Query or Mutation type. You need to define a field directive on the query o rmutation. Within the directive implementation, you will then have access to the resolver function being called and can wrap it to validate the input being sent to the query or mutation."))}c.isMDXComponent=!0}}]);