"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[7581],{3905:(e,t,o)=>{o.d(t,{Zo:()=>c,kt:()=>d});var a=o(7294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function n(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,a)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?n(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,a,i=function(e,t){if(null==e)return{};var o,a,i={},n=Object.keys(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)o=n[a],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var o=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=p(o),y=i,d=m["".concat(s,".").concat(y)]||m[y]||u[y]||n;return o?a.createElement(d,r(r({ref:t},c),{},{components:o})):a.createElement(d,r({ref:t},c))}));function d(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=o.length,r=new Array(n);r[0]=y;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[m]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<n;p++)r[p]=o[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,o)}y.displayName="MDXCreateElement"},6377:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>n,metadata:()=>l,toc:()=>p});var a=o(7462),i=(o(7294),o(3905));const n={title:"CrudRepository is an anti-pattern",tags:["Practices"]},r=void 0,l={permalink:"/2019/05/22/crudrepository",source:"@site/blog/2019/05-22-crudrepository.md",title:"CrudRepository is an anti-pattern",description:"CrudRepositories may seem like a nice way to boost productivity, but I think they lead to bad design and I'll explain why.",date:"2019-05-22T00:00:00.000Z",formattedDate:"May 22, 2019",tags:[{label:"Practices",permalink:"/tags/practices"}],readingTime:5.255,hasTruncateMarker:!0,authors:[],frontMatter:{title:"CrudRepository is an anti-pattern",tags:["Practices"]},prevItem:{title:'"Service" should be a banned word',permalink:"/2019/06/04/service"},nextItem:{title:"Book Review: Growing Object-Oriented Software, Guided by Tests",permalink:"/2019/04/16/growing-object-oriented-software-guided-by-tests"}},s={authorsImageUrls:[]},p=[{value:"First off, what is a CrudRepository?",id:"first-off-what-is-a-crudrepository",level:3},{value:"It leads to layered architecture",id:"it-leads-to-layered-architecture",level:3},{value:"How can you fix this?",id:"how-can-you-fix-this",level:3},{value:"So why move away from crud repositories if you must work more?",id:"so-why-move-away-from-crud-repositories-if-you-must-work-more",level:3},{value:"Conclusion",id:"conclusion",level:3}],c={toc:p},m="wrapper";function u(e){let{components:t,...o}=e;return(0,i.kt)(m,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"CrudRepositories may seem like a nice way to boost productivity, but I think they lead to bad design and I'll explain why."),(0,i.kt)("h3",{id:"first-off-what-is-a-crudrepository"},"First off, what is a CrudRepository?"),(0,i.kt)("p",null,"In Domain Driven Design, a repository is an object used to access persisted information, usually in a database. It provides methods for accessing certain objects and modifying them. CRUD is the smallest set of methods that can be used to work with your data. It consists of four explicitly named methods: Create, Read, Update, Delete. A CrudRepository is a class implementing these four methods. These are usually generic, and sometimes even automatically generated (see Spring). They usually look something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class CrudRepository<T> {\n   public int create(T t) {...}\n   public T read(int id) {...}\n   public void update(T t) {...}\n   public void delete(T t) {...}\n}\n")),(0,i.kt)("h3",{id:"it-leads-to-layered-architecture"},"It leads to layered architecture"),(0,i.kt)("p",null,"So the first problem I see with this is that it will usually lead to a layered architecture in the sense that your domain objects will now depend on database objects. The class your passing to this CrudRepository will contain information that pertains to the database, either through annotations or by the class being a direct mapping of a specific table. One of two things will usually happen once you start using this pattern: "),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"You might use domain objects, but your domain services will have to translate those into database objects and vice-versa to use the repository. This adds an extra responsibility to your domain services, making them harder to read."),(0,i.kt)("li",{parentName:"ol"},"You will simply use those database objects everywhere in your application, forcing your to write your services to contain all the domain logic and not having domain objects that contain their specific logic.")),(0,i.kt)("p",null,"Another big point to note with layered architecture is that whenever you change your database schema, you will likely have to change bits and pieces in all of your code. This will become harder and harder going further and take more and more time to complete."),(0,i.kt)("p",null,"Domain Driven Design encourages a clean separation between your domain objects and your database to reduce this problem. You should have a repository interface that resides within your domain and uses domain objects and the implementation should handle the translation between the domain objects and the database objects. A database change will then only affect your database objects and implementation of the repositories, but nothing else."),(0,i.kt)("h3",{id:"how-can-you-fix-this"},"How can you fix this?"),(0,i.kt)("p",null,"As mentioned earlier, you should have a repository interface inside your domain that uses domain objects. Something like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public interface EmployeeRepository {\n    public Employee createNewEmployee(String firstName, String lastName, String email, ...);\n    public Employee getEmployeeById(int id);\n    public Employee getEmployeeByEmail(String email);\n    public void saveEmployee(Employee employee);\n    public void deleteEmployee(Employee employee);\n}\n")),(0,i.kt)("p",null,"Your implementation will then have to translate between your domain objects (Employee in this case) and your database objects. This class can use the CrudRepository if you want to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class SqlEmployeeRepository : EmployeeRepository {\n    private CrudRepository<DbEmployee> crud;\n    \n    public Employee createNewEmployee(String firstName, String lastName, String email, ...) {\n        Employee employee = new Employee(firstName, lastName, email);\n        DbEmployee dbEmployee = new DbEmployee(employee);\n        employee.id = crud.create(dbEmployee);\n        return employee;\n    }\n    \n    public getEmployeeById(int id) {\n        return crud.read(id).toEmployee();\n    }\n    \n    public void saveEmployee(Employee employee) {\n        crud.update(new DbEmployee(employee));\n    }\n    \n    public void deleteEmployee(Employee employee) {\n        crud.delete(new DbEmployee(employee))\n    }\n    \n    ...\n}\n")),(0,i.kt)("p",null,"Now, whenever you change the database schema, you only need to change the database object (DbEmployee) and the implementation of the repository (SqlEmployeeRepository). If your domain doesn't need this added information, you can just ignore it. This is especially useful when working with a database that may be used by other application within your company. You probably don't care about half of the information in the database, so why force yourself to map it exactly? Create domain objects that contain just the information you need for your application and let the repository and database objects extract the pertinent information from the database."),(0,i.kt)("p",null,"Having the translation between the domain objects and the database objects in the repository also simplifies your domain services, making it easier to add new features or modify existing ones, and reducing the risk of errors in these objects."),(0,i.kt)("h3",{id:"so-why-move-away-from-crud-repositories-if-you-must-work-more"},"So why move away from crud repositories if you must work more?"),(0,i.kt)("p",null,"You'll more easily separate your different logic types between each layer of your application and it'll be easier to make modifications and understand your domain objects and services with this in mind in the long term.\nTake for example these two version of the same employee hiring method of a domain service:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public EmployeeService {\n    private CrudRepository<EmployeeEntity> repository;\n    private EmployeeEmailService emailService;\n    \n    public EmployeeBean hireEmployee(String firstName, String lastName) {\n        String email = emailService.generateEmailForNewEmployee(firstName, lastName);\n        EmployeeEntity entity = new EmployeeEntity(firstName, lastName, email);\n        entity.id = repository.create(entity);\n        return new EmployeeBean.Builder()\n            .id(entity.id)\n            .firstName(entity.firstName)\n            .lastName(entity.lastName)\n            .email(entity.email);\n    }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public EmployeeService {\n    private EmployeeRepository repository;\n    private EmployeeEmailService emailService;\n    \n    public Employee hireEmployee(String firstName, String lastName) {\n        String email = emailService.generateEmailForNewEmployee(firstName, lastName);\n        return repository.createNewEmployee(firstName, lastName, email);\n    }\n}\n")),(0,i.kt)("p",null,"In the first instance, using a crud repository, you get polluted with translation between different object types representing the same concept (an employee). Only two of the eight lines are pertinent and they're lost in the translation. For the second example, the two same lines doing application logic are the only two lines and it's a lot easier to read this way."),(0,i.kt)("p",null,"Another clear advantage is when you unit test these methods. The first example will force you to compare the EmployeeBean object your method return with the EmployeeEntity your mocked repository's method returned. If you then add a new field to your EmployeeBean or EmployeeEntity, you might miss this translation, but your test will still pass, probably breaking something down the line. In the second example, if you make your repository return an object and directly compare it to the object returned by the method, there's no way your comparison will fail, and if there are ever changes to your database schemas or domain objects, this code will still function correctly because it doesn't contain the translation."),(0,i.kt)("h3",{id:"conclusion"},"Conclusion"),(0,i.kt)("p",null,"Remember that an interface belongs to it's user, not it's implementer. Since the user of the repository is the service, the repository's interface belongs to the service and should talk in terms of domain objects, simplifying the service using it."))}u.isMDXComponent=!0}}]);