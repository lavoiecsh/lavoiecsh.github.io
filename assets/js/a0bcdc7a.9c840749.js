"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[9322],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>h});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var s=n.createContext({}),p=function(e){var t=n.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(r),m=a,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return r?n.createElement(h,l(l({ref:t},c),{},{components:r})):n.createElement(h,l({ref:t},c))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,l=new Array(o);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i[d]="string"==typeof e?e:a,l[1]=i;for(var p=2;p<o;p++)l[p]=r[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},7291:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var n=r(7462),a=(r(7294),r(3905));const o={title:"Day 7: The Sum of Its Parts",tags:["Challenges","Advent","C#"]},l=void 0,i={permalink:"/2018/12/07/advent2018-07",source:"@site/blog/2018/12-07-advent2018-07.md",title:"Day 7: The Sum of Its Parts",description:"Nice little graph problem today. I started by creating a Step class which contained references to other steps it depended on. The first part was then solved by looping and flagging steps as completed until all step where completed. Finding the next step to complete simply involved a little LINQ to determine the first (considering a list of steps ordered alphabetically) incomplete step for which all its requirements are completed:",date:"2018-12-07T00:00:00.000Z",formattedDate:"December 7, 2018",tags:[{label:"Challenges",permalink:"/tags/challenges"},{label:"Advent",permalink:"/tags/advent"},{label:"C#",permalink:"/tags/c"}],readingTime:1.375,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Day 7: The Sum of Its Parts",tags:["Challenges","Advent","C#"]},prevItem:{title:"Day 8: Memory Maneuver",permalink:"/2018/12/08/advent2018-08"},nextItem:{title:"Day 6: Chronal Coordinates",permalink:"/2018/12/06/advent2018-06"}},s={authorsImageUrls:[]},p=[],c={toc:p},d="wrapper";function u(e){let{components:t,...r}=e;return(0,a.kt)(d,(0,n.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Nice little graph problem today. I started by creating a Step class which contained references to other steps it depended on. The first part was then solved by looping and flagging steps as completed until all step where completed. Finding the next step to complete simply involved a little LINQ to determine the first (considering a list of steps ordered alphabetically) incomplete step for which all its requirements are completed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-C#"},"var nextStep = steps.First(s => !s.IsCompleted && s.Requirements.All(r => r.IsCompleted));\n")),(0,a.kt)("p",null,"For the second part, I thought of multiple possible solutions but ended up doing a simple matrix-like solution similar to the problem description example. This is done by assigning available steps to each idle worker, increasing the time by 1 second and starting over until all steps are completed."),(0,a.kt)("p",null,"Another possible solution could be to use a priority queue to determine the next completed step, reduce the time for the other running tasks according to the time spent to complete it and start the next task in the queue as long as there are enough workers. This solution could be implemented without creating a Worker class as I did."),(0,a.kt)("p",null,"Another possible approach could involve have workers push events when their step is completed and have an event handler that would assign him the next available step. This approach is similar to what is done in task scheduling programs, as those used on computing servers for example. As the steps are fictional here, it would involve creating a fictional task to complete (like simply waiting or watching a counter), so it would require a lot more work than the simpler solutions."))}u.isMDXComponent=!0}}]);