"use strict";(self.webpackChunkproper_code=self.webpackChunkproper_code||[]).push([[5216],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1640:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={title:"Day 12: Subterranean Sustainability",tags:["Challenges","Advent","C#"]},i=void 0,l={permalink:"/2018/12/12/advent2018-12",source:"@site/blog/2018/12-12-advent2018-12.md",title:"Day 12: Subterranean Sustainability",description:"This is the first problem that I still haven't an efficient way to solve the second part.",date:"2018-12-12T00:00:00.000Z",formattedDate:"December 12, 2018",tags:[{label:"Challenges",permalink:"/tags/challenges"},{label:"Advent",permalink:"/tags/advent"},{label:"C#",permalink:"/tags/c"}],readingTime:1.195,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Day 12: Subterranean Sustainability",tags:["Challenges","Advent","C#"]},prevItem:{title:"Day 13: Mine Cart Madness",permalink:"/2018/12/13/advent2018-13"},nextItem:{title:"Day 11: Chronal Charge",permalink:"/2018/12/11/advent2018-11"}},s={authorsImageUrls:[]},c=[],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This is the first problem that I still haven't an efficient way to solve the second part."),(0,a.kt)("p",null,"I went with a pretty simple solution for the first part, calculating the next generation by looking up whether each plant is alive or not in the notes. This worked fine for 20 generations."),(0,a.kt)("p",null,"Scaling this to the second part and it's 50,000,000,000 generations just isn't cutting it. After some tests, my code runs 1,000,000 generations in about 7 seconds. 50 billion generations would take me around 97 hours of computing which is doable but not something I want to run."),(0,a.kt)("p",null,"I skipped the second part for today and will come back to it later when I have more time or when I have an idea to improve my solution. My remaining ideas are to try to parallelize the computing of a generation or use memoization and check if some sections of the plants have been calculated before."),(0,a.kt)("p",null,"UPDATE: I came back to this problem on December 20th and noticed that at some point the cavern is full and just moves towards the right. So I changed my code to accommodate for this by checking if my state didn't change from the last iteration and checking the difference in the sum from the last iteration. At this point I saved the number of iterations remaining and simply multiplied that by the difference and added the last sum I saw."))}m.isMDXComponent=!0}}]);