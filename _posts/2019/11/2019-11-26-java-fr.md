---
layout: post
title: "Le problème avec Java ce n'est pas le langage, c'est le reste"
lang: fr
ref: java
date: 2019-11-26
categories: [Technologies]
tags: []
---
Je travaille avec Java comme langage principal pour plus d'un an maintenant, et j'en suis arrivé à la conclusion que le plus gros problème que les gens ont avec Java n'est pas le langage en lui-même, mais toutes les autres choses dont vous avez besoin pour faire des logiciels niveau entreprise avec Java. Puisque j'ai beaucoup travaillé avec C#, je vais faire quelques parallèles entre les deux.

## Spring
Spring est la plus grosse machine dans l'univers de Java et c'est difficile de trouver des remplacements pour sans avoir à combiner plusieurs autres librairies ensemble pour retrouver les fonctionnalités que Spring offre. Spring est surtout utilisé pour gérer l'injection de dépendance et la création de serveurs d'API. À part être très gourmant niveau ressources et prendre beaucoup de temps à démarrer, l'injection de dépendance est généralement faite par convention, en utilisant des noms d'interfaces et de classes qui suivent une convention spécifique. Configurer ceci est impossible ou difficile au point de ne pas valoir la peine, donc vous vous retrouvez à hacker vos noms de classe pour tout faire fonctionner. Spring n'utilise pas de convention pour les controlleurs par contre, ce qui est un avantage sur C#.

Dans le monde de C#, Spring est essentiellement remplacé par .NET Core, qui offre les mêmes fonctionnalités de création de serveur d'API, injection de dépendance et aussi du server-side rendering avec Razor (qui requiert une librairie externe comme Wicket ou Struts pour faire l'équivalent en Java).

## Database queries
Spring offre aussi JdbcTemplate pour interagir avec votre base de données, ou vous pouvez utilisez une autre librairie, Hibernate, si vous voulez un langage plus haut niveau pour accéder à vos données. Pour les deux, vous écrirez souvent du code SQL textuellement, du moins pour certaines requêtes, ce qui couple votre application avec votre base de données. Si vous voulez utiliser une autre base de données pour vos tests, il est possible que votre code SQL ne fonctionne pas avec cette base de données. Vous aurez donc le choix d'écrire une requête différente pour chaque base de données ou d'écrire du code moins performant et moins lisible pour fonctionner sur les deux bases de données.

De l'autre côté, C# introduit EntityFramework (et EntityFrameworkCore). Cette librairie offre une grande variété d'implémentations pour des bases de données SQL, et le code que vous écrivez est agnostic de l'implémentation puisque la librairie traduit du code LINQ en SQL dépendemment de la base de données. Ceci rend le changement d'une base de données à l'autre beaucoup plus facile.

## Ant/Maven/Gradle
Puisque l'on a tendance à ne pas écrer des trucs que d'autres ont déjà fait mieux, nous voulons la possibilité d'utiliser des librairies externes dans notre code. Puisque Java n'a pas de système de gestion de dépendance, vos choix sont de copier une librairie dans votre projet et la conserver à jour manuellement ou de vous fier à un outil externe pour télécharger ce dont vous avez besoin. Vos choix pour les outils externes sont généralement Maven ou Gradle, mais il y en a plusieurs autres, chacun avec leur fichiers de configuration et patron et façon de les utiliser. Ces outils gèrent souvent aussi la compilation pour les projets ayant plusieurs packages. Certains autres outils, comme Ant, ne gèrent que la compilation.

Tous ces différents outils font en sorte qu'il est impossible d'avoir une manière approuvée et unifiée pour gérer la compilation puisque chaque outil est développé indépendemment, peut avoir des bogues différents et chercher de l'information sur un outil va souvent être mélangé avec l'information d'un autre (Maven et Gradle ont beaucoup de problèmes à ce niveau). Ajoutez à ceci le fait que vous devrez peut-être écrire un script au-dessus de l'outil pour le faire fonctionner dans votre projet (Gradle Wrapper).

Puisque Java ne force pas la création de fichiers pour définir les packages et que tout est fait à travers la structure des fichiers et répertoires, chacun de ces outils va définir un fichier de configuration séparé pour chaque package contenant les librairies externes requises. Même avec des IDEs plus avancés comme Intellij, il arrive qu'il ne soit pas capable de modifier automatiquement le fichier associé à votre outil, et vous aurez donc à le modifier manuellement.

Comparons maintenant avec C#, il y a une manière unifiée de compiler et d'inclure des librairies externes est tout est géré par un seul outil. C# vous force à avoir un fichier dans chaque package (project) dans votre projet (solution) qui défini tous les fichiers inclus dans le package ainsi que chaque dépendance requise, autant entre les différents packages que les librairies externes. Il y a un seul outil de compilation pour tout gérer, donc trouver de l'information est facile. Tout ceci est rendu encore plus facile par le fait que tous les IDEs supportant C# (IDEA, Visual Studio, VSCode) gèrent bien les modifications des fichiers de configuration (.sln et .csproj/.fsproj/.vbproj), donc vous n'avez jamais à les modifier vous mêmes.

## JVM
Bien que la JVM offre la possibilité de facilement transférer votre application sur pratiquement n'importe quelle architecture de processeur, elle vient souvent avec un gros coût en performance, surtout au démarrage de votre application. Ceci ne vous affecte pas normalement, surtout dans le cas d'un serveur, mais peut ajouter beaucoup de temps lorsque vous redémarrez souvent votre application, par exemple en faisant des tests unitaires et intégrés. L'autre problème avec les tests unitaires causé par ceci est que vous devez créer une application pour chaque test ou suite de tests que vous voulez lancer. Malgré le fait que ceci est fait à travers votre platforme de test (comme JUnit ou TestNG), ça veut dire que vous n'avez pas accès à certaines des fonctionnalités que C# offre pour les tests unitaires comme lancer un test ou une série de tests facilement et rapidemment, relancer seulement les tests qui n'ont pas passé et avoir tout ça lié dans un engin de test externel qui peut rouler vos tests en arrière plan à chaque changement.

## Conventions
Tout ce que j'ai mentionné jusqu'à date, en plus de toute la documentation que vous trouvez en ligne et le code que vos collègues ont écrit avant vous vous forcent à utiliser des conventions que je déteste particulièrement. Quoique certains de ces problèmes sont aussi présents en C#, je trouve que Java les force plus sur vous. En voici quelques unes:

### JavaBeans
Ceci est le plus gros coupable pour des mauvais designs d'applications en Java. Vous êtes forcés d'écrire des classes de données qui ne contiennent essentiellement aucune logique du domaine. Ces objets doivent avoir des getters pour toutes leurs propriétés et des setters pour la plupart (sinon toutes). Ceci crée beaucoup de code inutile dans beaucoup de classes, les rendant illisible très rapidement. Puisque tout est public dans ces objets, c'est assez difficile de renforcer une séparation des domaines. Vous êtes aussi forcé de fournir un constructeur sans paramêtre pour que les engins puissent créer des instances et assigner leurs propriétés par après, impliquant que vous pouvez vous retrouver avec des objets dans des états invalides. Ces objets finissent par être utilisés pour simpliment transférer de l'information, brisant l'idée de séparation de domaine et de logique du Domain Driven Design.

### DAO
Le problème ici n'est pas la convention, mais comment les gens l'utilisent. Ici encore on va à l'encontre du DDD en favorisant une architecture par couche. Dans un repository typique, vous retourneriez un objet du domaine pour que vous services l'utilise directement, mais dans les DAOs, vous retournez généralement une représentation de votre base de donnée et votre service doit maintenant faire la traduction, ce qui se termine généralement par un simple mapping vers un JavaBeans propriété par propriété sans logique de plus. Tout ceci vous force subtilement à utiliser le DAO directement et modifier les entités retournées sans jamais toucher au service ou au beans parce que c'est plus simple comme ça. Si vous voulez un jour déplacer vos entités d'un monolith à des microservices par exemple, vous aurez beaucoup de misère à trouver et modifier toutes les références au DAO et aux entités et les remplacer par le bean où c'est nécessaire.

### Interfaces et implémentations
Beaucoup trop souvent, surtout à cause des conventions d'injection de dépendances de Spring, vous vous retrouvez avec une seule implémentation pour votre interface. L'interface aura un nom claire et valide, mais la seule implémentation aura alors un suffixe `Impl`. Même si vous tentez de séparer l'interface dans un package différent pour réduire les accès possible, c'est un peu inutile parce que l'implémentation n'est pas vraiment cachée. Ceci brise habituellement le but et l'appropriation des interfaces. Une interface appartient à celui qui l'utilise et aura un nom et des méthodes qui reflètent ceci. L'implémentation pourra alors avoir son propre langage, qui ne sera pas visible de l'interface. Java a tendance à renverser ce patron et rendre les interfaces génériques avec une seule implémentation, créant essentiellement juste une collection de classes qui se parlent entre-elles sans le besoin d'interface. J'ai parlé de ceci dans mes entrées précédentes, mais si votre seule implémentation pour une interface a le même nom que celle-ci, ça sent mauvais. Il y a une forte chance que les méthodes ne sont utilisées que dans des tests, mais vous ne le savez pas.

## Génération de code
Puisque Java est un langage très verbeux, et qu'utiliser des conventions comme JavaBeans vous force a écrire beaucoup de code, plusieurs d'outils de génération de code ont fait surface pour réduire le code à écrire. La librairie la plus connue est Lombok. J'adore leurs annotations, surtout pour le patron builder, mais le plus gros problème avec ceux-ci sont qu'ils causent souvent des erreurs de compilation parce qu'une classe modifiée n'a pas été regénérée ou qu'elle utilise une version en cache. Ceci est particulièrement visible lorsque vous écrivez du nouveau code dans un IDE puisqu'il n'arrive pas à trouver vos nouvelles propriétés jusqu'à ce que vous ayez regénéré la classe. Ça peut devenir très pénible lorsque vous avez à toucher à plusieurs classes ou que vous faites du TDD.

## Conclusion
Comme mentionné, le plus gros problème de Java n'est pas le langage, mais tout ce qui vient autour: JVM, Ant/Maven/Gradle, Spring, conventions et génération de code. Java (et d'autres langages de la JVM comme Kotlin, Scala et Clojure) offrent beaucoup de belles fonctionnalités et de facilité pour écrire des bons programmes (surtout avec les nouvelles versions de Java). Il faut juste faire attention de ne pas tomber dans certains pièges des outils et des conventions.

Comme petite addition rigolote, allez voir la version enterprise de FizzBuzz, qui présente beaucoup des patrons que j'ai mentionné aujourd'hui: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition.
